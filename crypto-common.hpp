/*
The MIT License

Copyright (c) <2008,2009> <Deepak Garg dg@cs.cmu.edu>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

#ifndef __CRYPTO_COMMON_H
#define __CRYPTO_COMMON_H

#include <iostream>
#include <string.h>
#include <stdio.h>
#include <openssl/hmac.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/bio.h>
#include <openssl/evp.h>

using namespace std;

#define MAX_MAC_LENGTH EVP_MAX_MD_SIZE
// The maximum possible length of MAC that may be generated by SSL
// Note that this will usually not be attained. Instead all hashes we
// generate will have length MAC_LENGTH (see below). However, buffers
// used to hold MACs should be allocated to this length for extra
// safety.

#define SYM_KEY_LENGTH 20              
// Length of symmetric keys in bytes. We are using HMAC with SHA1, so
// key is 160 bits or 20 bytes in length

#define MAC_LENGTH 20
// Length of MACs generated in bytes. We are using HMAC with SHA1 so
// output is 160 bits or 20 bytes in length

#define CRYPTO_ERR_NOFILE -1  /* Bad file */
#define CRYPTO_ERR_FORMAT -2  /* Wrong format */ 
#define CRYPTO_ERR_INTERNAL -4  /* Openssl error */ 
#define CRYPTO_ERR_MEM      -8  /* Not enough memory */

class PubKey
{ 
  EVP_PKEY * pubkey;
  
 public:
 
  PubKey(EVP_PKEY * pkey) : pubkey(pkey) { 
    ;
  }
  
  EVP_PKEY * getKey() {
    return pubkey;
  }

  ~PubKey() {
    if (pubkey != NULL) 
      {
	EVP_PKEY_free(pubkey);
      }
  }
  
};

class PrivKey
{
  EVP_PKEY * privkey;
  
 public:
  
  PrivKey(EVP_PKEY * pkey) : privkey(pkey) { }

  EVP_PKEY * getKey() {
    return privkey;
  }

  ~PrivKey() {
    if (privkey != NULL) {
      EVP_PKEY_free(privkey);
    }
  }
};


//-----------------------------------------------------------------------------

inline PubKey * privKeyToPubKey (PrivKey * privkey)
{
  if (privkey == NULL || privkey -> getKey() == NULL) return NULL;

  EVP_PKEY * nkey = EVP_PKEY_new();

  // EVP_PKEY_get1_RSA will duplicate the RSA key.
  // EVP_PKEY_assign_RSA will force the RSA key to be freed with nkey
  EVP_PKEY_assign_RSA(nkey, EVP_PKEY_get1_RSA(privkey -> getKey()));
  
  return new PubKey(nkey);
}

/* Compare public components of keys. Return true only if the public
   components of the two given keys are the same, false otherwise. The
   function can be used to check if two public keys are equal or if a
   private and public key correspond. It CANNOT be used to compare two
   private keys, because it does not compare the private components.
*/

inline bool cmp_rsa_keys(EVP_PKEY* key1, EVP_PKEY* key2) { 
  if (key1->type != key2->type) 
    return false; // keys aren't of the same type 

  if (key1->type != EVP_PKEY_RSA)
    return false;   // this function only handles RSA keys 
  
  if (BN_cmp(key1->pkey.rsa->n,key2->pkey.rsa->n) != 0 ||
      BN_cmp(key1->pkey.rsa->e,key2->pkey.rsa->e) != 0)
    return false;   // The public components do not match 
  else
    return true;
 
}

inline bool eq_PubKey(PubKey * key1, PubKey * key2)
{
  return cmp_rsa_keys (key1 -> getKey(), key2 -> getKey());
}

inline bool correspond(PrivKey * privkey, PubKey * pubkey)
{
  return cmp_rsa_keys (privkey -> getKey(), pubkey -> getKey());
}

//-----------------------------------------------------------------------------

/* Compute HMAC on data (of size datasize) using key key[] of size
   keylen. Note that key must be in binary, and its length must be in keylen.
   Write output to buffer output, and return size of output in
   outputsize. The maximum possible value of *outputsize will be
   MAX_MAC_LENGTH
 */
inline void computeHMAC(const unsigned char * key, int keylen,
			const char * data, int datasize,
			unsigned char * output, int * outputsize // output parameters
			)
{
  HMAC(EVP_sha1(), 
       key, keylen, 
       (const unsigned char *) data, datasize, 
       output, (unsigned *) outputsize);
}


/* Similar to function computeHMAC, but takes a context as input for
   slightly better performace. Use this function as follows:

   HMAC_CTX ctx;
   HMAC_CTX_init(&ctx);
   ...
   ...
   computeHMAC2(&ctx, ...);
   ...
   ...
   computeHMAC2(&ctx, ...);
   ...
   ...
   HMAC_CTX_cleanup(&ctx);

   Note that you can make multiple calls without reinitializing the
   context every time. This gives a speed up of approximately 6% over
   the above function.
*/

inline void computeHMAC2(HMAC_CTX * ctx, 
			 const unsigned char * key, int keylen,
			 const char * data, int datasize,
			 unsigned char * output, int * outputsize)
{
  HMAC_Init_ex (ctx, key, keylen, EVP_sha1(), NULL);
  HMAC_Update(ctx, (const unsigned char *) data, datasize);
  HMAC_Final(ctx, output, (unsigned *) outputsize);
}

//---------------------------------------------------------------------------

// Converts a single hex digit to binary.  Returns a char whose
// lower four bits contain the binary corresponding to the hex
// digit. If the input digit in not in [0-9a-fA-F], it returns a
// character whose value is larger than 15.
inline unsigned char hexToBin(char c)
{
  if (c >= '0' && c <= '9') 
    return (((unsigned char) c) - '0');
  else if (c >= 'a' && c <= 'f')
    return (((unsigned char) c) - 'a' + 10);
    else if (c >= 'A' && c <= 'F')
      return (((unsigned char) c) - 'A' + 10);
    else return 16;
}

// Converts an unsigned char containing a value from 0-15 to a hex.
inline char binToHex(unsigned char b) 
{
  return (b <= 9 ? (b + '0') : (b - 10 + 'a'));
}

// Returns the binary representation of a key/mac/... in hex. The
// input inHex must have an even number of characters, all in the set
// [0-9A-Fa-f]. The buffer outBin must have a size at least half that
// of the input. Note that this function does not check the input for
// format (i.e. that it has only the characters [a-fA-F0-9]), unless
// the last argument (checkFormat) is true. 

// Return value: if checkFormat is false, return value is always 1. If
// it is true, return value is 1 if format is correct, and 0 if format
// is wrong.

inline int hexToBinary(const char * inHex, int inlen, unsigned char * outBin, bool checkFormat = false) {
  int i;
  if (!checkFormat) {
    for (i = 0; i < inlen/2; i++) {
      outBin[i] = (unsigned char)(hexToBin(inHex[2 * i + 1]));
      outBin[i] = outBin[i] | (((unsigned char) (hexToBin(inHex[2 * i]))) << 4);
    }
    return 1;
  }
  else {
    // checkFormat is true, so we must do a more expensive procedure per loop
    for (i = 0; i < inlen/2; i++) {
      unsigned char a = hexToBin(inHex[2 * i + 1]);
      unsigned char b = hexToBin(inHex[2 * i]);
      if (a <= 15 && b <= 15) {
	outBin[i] = a | (b << 4);
      }
      else return 0;
    }
    return 1;
  }
} 

// Returns the hex representation of a binary input. The size of the
// output buffer outHex must be at least twice that of the input. 

inline void binaryToHex (const unsigned char * inBinary, int inlen, char * outHex) {
  int i;
  for (i = 0; i < inlen; i++) {
    outHex [2 * i] = binToHex ((inBinary[i] & 0xf0) >> 4);
    outHex [2 * i + 1] = binToHex (inBinary[i] & 0x0f);
  }
}

//---------------------------------------------------------------------------


/* Generate an RSA signature using the private key 'pkey' on data 'd'
   of length 'len', after producing a MD5 digest on d. Writes output
   to 'outbuf' and length of output to 'outlen'. Note that 'outbuf'
   should have a minimum space of size
   getSignatureLength(pkey). Returns 1 on success, or error code on
   error. */

inline int createSignature (PrivKey * pkey, const char * d, int len, 
			    unsigned char * output, int * outlen)
{
  if (pkey == NULL || pkey -> getKey() == NULL) return CRYPTO_ERR_FORMAT;
  
  EVP_MD_CTX * ctx = EVP_MD_CTX_create();
  
  if (ctx == NULL) return CRYPTO_ERR_INTERNAL;


  if ((EVP_SignInit(ctx, EVP_md5()) == 1) &&
      (EVP_SignUpdate (ctx, d, (unsigned) len) == 1) &&
      (EVP_SignFinal (ctx, output, (unsigned int *) outlen, pkey -> getKey()) == 1)) {
    EVP_MD_CTX_destroy(ctx);
    return 1;
  }

  EVP_MD_CTX_destroy(ctx);
  return CRYPTO_ERR_INTERNAL;
}


/* Verify an RSA signature using the public key 'pkey' on data 'd' of
   length 'len', after producing a MD5 digest on d. The signature to
   be checked is in 'sig' and its length is in 'siglen'.  Returns 1 if
   check succeeds, 0 if it fails, an error code on error. */


inline int verifySignature (PubKey * pkey, const char * d, int len, 
			    unsigned char * sig, int siglen)
{
  if (pkey == NULL || pkey -> getKey() == NULL) return CRYPTO_ERR_FORMAT;

  EVP_MD_CTX * ctx = EVP_MD_CTX_create();
  
  if (ctx == NULL) return CRYPTO_ERR_INTERNAL;


  if ((EVP_VerifyInit(ctx, EVP_md5()) == 1) &&
      (EVP_VerifyUpdate (ctx, d, (unsigned) len) == 1)) {

    int r = EVP_VerifyFinal (ctx, sig, (unsigned) siglen, pkey -> getKey());
    EVP_MD_CTX_destroy(ctx);
    if (r >= 0) return r; 
    else return CRYPTO_ERR_INTERNAL;
  }

  EVP_MD_CTX_destroy(ctx);
  return CRYPTO_ERR_INTERNAL;
}

/* Return the size of signatures generated by a public key. Will
   return this size or error code */

inline int getSignatureLength(PubKey * pkey) 
{
  if (pkey == NULL || pkey -> getKey() == NULL) return CRYPTO_ERR_FORMAT;
  else return (EVP_PKEY_size (pkey -> getKey()));
}

inline int getSignatureLength(PrivKey * pkey) 
{
  if (pkey == NULL || pkey -> getKey() == NULL) return CRYPTO_ERR_FORMAT;
  else return (EVP_PKEY_size (pkey -> getKey()));
}

//---------------------------------------------------------------------------

/* For keys, PEM encoded refers to openssl's encoding. In that case,
   the key is written in PEM, and surrounded by header lines like
   "-----BEGIN RSA KEY-----" and "-----END RSA KEY-----"
*/


/* Reads a PEM encoded public key from a file. Returns a PubKey * on
   success, NULL on error. Note that PEM here refers to 
*/
 
inline PubKey * readPubKeyFromFile (const char * fname) 
{
  FILE * fp = fopen (fname, "r");
  if (fp == NULL) return NULL;
  
  
  EVP_PKEY * pubkey = PEM_read_PUBKEY (fp, NULL, NULL, NULL);

  fclose(fp);

  if (pubkey == NULL) return NULL;
  
  return (new PubKey(pubkey));
}

/* Reads a PEM encoded public key from a memory string. Returns a
   PubKey on success, NULL on error */

inline PubKey * readPubKeyFromString (const char * buf, int len)
{
  BIO * bp = BIO_new_mem_buf((void *) buf, len);
  
  EVP_PKEY * pubkey = PEM_read_bio_PUBKEY(bp, NULL, NULL, NULL);

  BIO_free(bp);

  if (pubkey == NULL) return NULL;

  
  return (new PubKey(pubkey));
}

/* Writes a PEM encoded public key to a file (deleting its existing
   contents). Returns 1 on success, error code on failure. */

inline int writePubKeyToFile (PubKey * pkey, const char * fname)
{
  if (pkey == NULL) return CRYPTO_ERR_FORMAT;
  
  EVP_PKEY * pub = pkey -> getKey();

  FILE * fp = fopen (fname, "w");
  if (fp == NULL) return CRYPTO_ERR_NOFILE;
  
  
  int r = PEM_write_PUBKEY(fp, pub);
  fclose(fp);

  if (r == 0) 
    return CRYPTO_ERR_FORMAT;
  else 
    return 1;
}

/* Writes a public key to a memory buffer as a PEM encoded
   string. Returns length of output on success, error code on
   failure. The buffer must be long enough to hold the output, else an
   error will result. A 1K buffer should suffice for a 1024 bit
   key. */

inline int writePubKeyToString(PubKey * pkey, char * buf, int len)
{
  if (pkey == NULL) return CRYPTO_ERR_FORMAT;
  
  EVP_PKEY * pub = pkey -> getKey();
  BIO *bp = BIO_new(BIO_s_mem());

  int r = PEM_write_bio_PUBKEY(bp, pub);
  if (r == 0) 
    return CRYPTO_ERR_FORMAT;
  
  BUF_MEM * bptr;
  BIO_get_mem_ptr (bp, &bptr);

  const char * str = bptr -> data;
  int l = bptr -> length;

  if (l > len) return CRYPTO_ERR_MEM;

  memcpy(buf, (void *) str, l);
  BIO_free(bp); // bptr is automatically freed
  return l;
}


//-------------------------------------------------------------------------

/* Reads a PEM encoded private key from a file. Returns a PrivKey * on
   success, NULL on error.
*/
 
inline PrivKey * readPrivKeyFromFile (const char * fname) 
{
  FILE * fp = fopen (fname, "r");
  if (fp == NULL) return NULL;
  
  EVP_PKEY * privkey = PEM_read_PrivateKey (fp, NULL, NULL, NULL);

  fclose(fp);

  if (privkey == NULL) return NULL;
  
  return (new PrivKey(privkey));
}

/* Reads a PEM encoded private key from a memory string. Returns a
   PrivKey on success, NULL on error */

inline PrivKey * readPrivKeyFromString (const char * buf, int len)
{
  BIO * bp = BIO_new_mem_buf((void *) buf, len);
  
  EVP_PKEY * privkey = PEM_read_bio_PrivateKey(bp, NULL, NULL, NULL);

  BIO_free(bp);

  if (privkey == NULL) return NULL;

  
  return (new PrivKey(privkey));
}

/* Writes a PEM encoded private key to a file (deleting its existing
   contents). Returns 1 on success, error code on failure. */

inline int writePrivKeyToFile (PrivKey * pkey, const char * fname)
{
  if (pkey == NULL) return CRYPTO_ERR_FORMAT;
  
  EVP_PKEY * priv = pkey -> getKey();

  FILE * fp = fopen (fname, "w");
  if (fp == NULL) return CRYPTO_ERR_NOFILE;
  
  
  int r = PEM_write_PrivateKey(fp, priv, NULL, NULL, 0, NULL, NULL);
  fclose(fp);

  if (r == 0) 
    return CRYPTO_ERR_FORMAT;
  else 
    return 1;
}

/* Writes a private key to a memory buffer as a PEM encoded
   string. Returns length of output on success, error code on
   failure. The buffer must be long enough to hold the output, else an
   error will result. A 1K buffer should suffice for a 1024 bit
   key. */

inline int writePrivKeyToString(PrivKey * pkey, char * buf, int len)
{
  if (pkey == NULL) return CRYPTO_ERR_FORMAT;
  
  EVP_PKEY * priv = pkey -> getKey();
  BIO *bp = BIO_new(BIO_s_mem());

  int r = PEM_write_bio_PrivateKey(bp, priv, NULL, NULL, 0, NULL, NULL);
  if (r == 0) 
    return CRYPTO_ERR_FORMAT;
  
  BUF_MEM * bptr;
  BIO_get_mem_ptr (bp, &bptr);

  const char * str = bptr -> data;
  int l = bptr -> length;

  if (l > len) return CRYPTO_ERR_MEM;

  memcpy(buf, (void *) str, l);
  BIO_free(bp); // bptr is automatically freed
  return l;
}

//----------------------------------------------------------------------------------

// Code for base64/PEM encoding and decoding

//----------------------------------------------------------------------------------



/* Determine how long a base64 encoded string will be. The input
   argument is the length of the input string.
 */

inline int base64Length(int inlen)
{
  return (4 * ((inlen + 2) / 3));
}

/* Determine how long a PEM encoded string will be. The input
   argument is the length of the input string.
 */

inline int pemLength(int inlen)
{
  int b64l = base64Length(inlen);
  int extra = ((b64l == 0) || (b64l % 64 != 0)) ? 1 : 0;

  return (65 * (b64l / 64) + (b64l % 64) + extra);
}



/* Encode a char string to base64. Note that the output is not PEM
   encoded, so it has no newlines. 

   const char * in -- string to encode (need not be null terminated)

   int len -- length of the string

   char * out -- output buffer, must be long enough to hold the output

   Call base64Length to determine length needed in the output buffer.
*/

inline void base64Encode(const char * in, int len, char * out) {
  EVP_EncodeBlock((unsigned char *) out, (unsigned char *) in, len);
}

/* Decode a base64 encoded strong to characters. The input must not be
   PEM encoded, so it should not have any newlines.

   const char * in -- string to decode (need not be null terminated)

   int len -- length of the input string

   char * out -- output buffer, must be long enough to hold the
   output. The output will always be less than the length of the
   input, so this buffer may be made as long as the input.

   Returns the size of output

 */

inline int base64Decode(const char * in, int len, char * out) 
{
  int r = EVP_DecodeBlock ((unsigned char *)out, (unsigned char *) in, len);

  /* Fix the returned length r. This is a bug in OpenSSL */
  const char * p = in + len - 1;
  while (*p == '=') {
    r --;
    p --;
  }

  return r; 
}

/* Encode in PEM. This basically encodes in base64 using base64Encode,
   and then inserts a '\n' every 64 characters.

   The output will have length pemLength(len), and the output buffer
   must be at least this long
*/

inline void pemEncode(const char * in, int len, char * out)
{
  int base64len = base64Length(len);

  char * buf = new char [base64len + 1];

  base64Encode(in, len, buf);

  int i = 0;
  for ( ; i < base64len; i++) {
    *out ++ = buf[i];
    if ((i+1) % 64 == 0) {
      *out ++ = '\n';
    }
  }

  if (base64len == 0 || base64len % 64 != 0) {
    *out ++ = '\n';
  }

  delete [] buf;
}

/* 
   Decode PEM to characters. This will first decode from PEM to
   base64, i.e., remove all whitespace. Then it will call
   base64Decode. Returns size of final output. Note that this is
   guaranteed to be less than the size of the input (if the input is
   correct PEM).

*/

inline int pemDecode(const char * in, int len, char * out)
{
  char * buf = (char *) malloc(len);
  int i=0,j=0;

  /* Remove newlines and copy to buf */
  for (i = 0; i < len; i++) {
    // Ignore whitespace
    if (in[i] != '\n' && in[i] != '\r' && in[i] != '\t' && in[i] != ' ') {
      buf[j++] = in[i];
    }
  }

  int r = base64Decode (buf, j, out);

  free(buf);
  return r;
}


#endif
